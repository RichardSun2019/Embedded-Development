# 智能小车制作

## 序

制作小车, 智能化的小车, 是一个有趣的故事. 要想把故事讲完整并不容易, 因为这涉及到很多的背景知识, 以电子电路知识为主. 然而如果为这些知识阻碍, 我们无法享受其中的过程, 是为舍本而逐末, 与我们的初衷大相径庭. 所以记住一点, 一定要快乐! 一定要快乐! 一定要快乐! (重要的事情说三遍)

在此基础上, 能掌握原理则掌握, 掌握不了则会用即可. 无数次的实践证明, 先学知识再去动手做, 效率是十分低的. 我们要选一条最直接最简单的路. 而且当前网路技术十分发达, ChatGPT已经活跃于生活的方方面面. 利用人工智能学习新的知识, 事半功倍. 

我们的现实目的很简单, 做一个小车, 一个受我们控制的小车. 试想一下, 把我们想要的东西用简单的原件进行组合, 那就是电源+若干电机. 但是, 仅仅这样我们并不能控制它. 需要进行的控制可以分为三种: 1.电机通电/断电; 2.电机的转速; 3.电机之间的配合. 而电机的控制信号有两种来源: 1.人为主观因素控制; 2.外界客观信号控制. 这就要求小车有以下几种能力: 1.能收到人类给出的信号; 2.能感知外界的信号; 3.能对收到的信号做出程式化的相应. 此即为智能小车的基本思路. 然而以上这些复杂的过程不可能通过中学物理实验的工具来实现, 所以必须使用芯片. 所以制作智能小车就是理解芯片的过程. 从认识论的角度出发, 我们先从最简单的芯片--单片机出发, 还原智能小车的制作过程. 



千里之行始于足下, 加油吧, 少年!

## 一. 智能小车总览



## 二. 半成品:电源+电机

### 电源

### 电机

#### 直流电机的种类与选择

目前市面的直流电机主要分为**普通电机**和带动齿轮传动机构的**直流减速电机**。 如图: 左为日本马步奇高速电机 右为N20 减速直流电机.

![]( typorafile\motor.PNG)

对于不太追求速度的场合应优先选用减速直流电机.

**传动比**: 电机的传动比（也称为减速比）是指驱动装置（通常是电机）的输出转速与传动装置（通常是齿轮箱或皮带传动）的输入转速之间的比值。它描述了传动装置如何减慢电机的转速以提供所需的输出转矩。

传动比的数值可以通过比较输出转速和输入转速来计算。例如，如果电机的输出转速为1000转/分钟，而传动装置的输入转速为500转/分钟，则传动比为2:1（或简写为2）。这意味着电机的输出转速是传动装置输入转速的两倍。

传动比的选择取决于所需的输出转矩和转速，以及所使用的传动装置的特性。较高的传动比可以提供更大的输出转矩，但会减慢输出转速。相反，较低的传动比可以提供更高的输出转速，但输出转矩会相应减小。因此，在选择传动比时需要考虑到应用的具体要求。

#### 直流电机的电路设计

三个关注点:

- 如何增大驱动
- 如何实现换向
- 如何实现调速  

对于**第一个问题**，主要原因是电机属于大功率的器件，而单片机的 I/O 口所提供的电流往往十分有限，所以必须外加驱动电路，比如说由三极管组成放大电路。  

对于**第二个问题**，直流电机的方向改变需要改变电机的极性，即正负反接，但目前大多数机器人制作中使用的是直流无刷电机，由于没有电刷，而供电电源通常又为单电源，所以需要设计一个电子开关以实现换向功能（此电子开关开闭的控制信号通常可以通过单片机引脚提供）。  

对于**第三个问题**，机器人是一个需适应不同环境的智能体，其运动速度需要不断的改变，此时就需要想法设计相应电路以实现调速度。  

目前比较通用的方法是，**设计 H 桥电路和利用单片机产生 PWM 波信号**。

H 桥电路是用硬件的方法设计一个电路，它可以解决前面两个问题。而第三个问题速度的调节则是通过软件的方法，利用单片机 I/O口生产 PWM 波信号加以实现。  

## 三. 信号的收发与响应

### 红外技术和射频(无线)技术

1. 采用**红外技术**的产品有方向性，发射器必须对准接收器，并且中间不能有阻挡物。距离一般不超过7米、不受电磁干扰,红外类产品的优势是产品成本低、价格便宜。
2. 采用**射频技术**的产品是用无线电波来传送控制信号的，它的特点没有方向性，可以不“面对面”控制、距离远，可达数十米。发射器和接收器之间只要没有能起屏蔽作用的金属阻挡物，就可正常使用。射频技术的产品成本通常要高一些，但其无方向性，使用更方便，所以更受用户的欢迎。

### 红外信号

红外信号处理分为红外信号发射和红外信号接受两部分.

#### 发射部分

采用HT6221芯片进行红外编码和发射, 编码协议为NEC协议. 该协议的特点为:

1. 8位地址码, 8位命令码; 完整发射两次地址码和命令码, 以提高可靠性;
2. 脉冲时间长短调制方式; (见下)
3. 38KHz载波频率, 位时间为***0:1.12ms(0.56*2),  1: 2.25ms( 0.56*4+1)***

![]( typorafile\IR1.PNG)

![]( typorafile\IR2.PNG)

上图所示为 NEC 协议的典型脉冲链。协议规定低位首先发送，如上图所示的情况，发送的地 址码为”59”，命令码为”16”。每次发送的信息首先是用于调整红外接收器增益的 9ms AGC(自动增益控制)高电平脉冲，接着是 4.5ms 的低电平，接下来便是地址码和命令码。地址码和命令码发送两次，第二次发送的是反码 (如：1111 0000 的反码为 0000 1111)，用于验证接收的信息的准确性。  

![]( typorafile\IR3.PNG)

尽管你一直按住那个按键，一串信息只能发送一次。如果一直按着按键，发送的则是以110ms 为周期的重复码，重复码是由 9ms 的 AGC 高电平和 4.5ms 的低电平及一个 560us 的高电平组成。  

HT6621遥控器键值(HS-021): 3V扣式锂锰电池, 距离  8m~10m  

<img src="typorafile\IR4.jpg" style="zoom:30%;" />

**在红外遥控音乐盒实验中, 因为按键按的时长而对结果产生影响, 需要注意!!!**

因为虽然可以接收到正确的码值, 但是

#### 接收部分

红外接收部分由HS0038红外接收头和51单片机控制电路构成. 

<img src=" typorafile\IR5.PNG" style="zoom:75%;" />

注意到, 当HS0038红外接收头接收到红外载波信号时,  OUT引脚(这里是IR引脚)会产生一个低电平. 如果C语言编程时采用IT1=1, 即外部中断1且延边(下降沿)触发, 那么此时就会产生一个外部中断1. 在终端函数子程序中可以进行解码操作. 

### 无线信号

无线信号的发射由 315M, 433M, 2.4G等无线模块实现, 接收由51单片机和接收电路构成.

#### 315M无线模块

1. 315m无线模块广泛地运用在车辆监控、遥控、遥测、小型无线网络、无线抄表、门禁系统、小区传呼、工业数据采集系统、无线标签、身份识别、非接触RF智能卡、小型无线数据终端、安全防火系统、无线遥控系统、生物信号采集、水文气象监控、机器人控制、无线232数据通信、无线485/422数据通信、数字音频、数字图像传输等领域中。
2. 市场上最常用的315M发射芯片XC4388。 该芯片包括了一个**功率放大器**，**单稳态电路**和一个由由内部电压控制振荡器和循环过滤的锁相环。单稳态电路用来控制锁相环和功率放大器，使其在操作时可以快速启动。XC4388具备自动待机功能，待机电流小于1uA；所需外部器件很少，频率范围为250MHz～450MHz。

#### 433M无线模块

1. 433M/315M无线发射芯片通常是用于远程无钥匙进入系统（RKE）的高性能的OOK/ASK发射器。国内市场使用量最大的发射芯片为XC4388。应用领域：无钥匙进入系统、远程控制系统、车库门开启器、报警系统、安防系统、无线传感器
2. 433M无线模块的**接收灵敏度高，绕射性能好**，我们一般使用433MHz无线模块来实现主从模式的通信系统当中。这样主从拓扑结构其实就是一个智能家居，它具有网络结构简单，布局容易，上电时间短的优势。433MHz、470MHz现在已在智能抄表行业广泛应用。
3. 市场上常用的433M发射芯片CC1020。该芯片包括了一个功率放大器，单稳态电路和一个由由内部电压控制振荡器和循环过滤的锁相环。单稳态电路用来控制锁相环和功率放大器，使其在操作时可以快速启动。CC1020具备自动待机功能，待机电流小于1uA;所需外部器件很少，频率范围为250MHz～510MHz。
4. 433无线模块功耗低，功能强大，被广泛应用于机器人控制，智能家居，无线抄表等领域，产品是工业级设计，适用于室外低劣环境。当模块在使用中发现距离不够的时候，经常建议选用符合的天线，以达到增加通信距离的目的。

#### 2.4G无线模块

1. 2.4ghz无线技术，是一种短距离无线传输技术，供开源使用。2.4GHz所指的是一个工作频段，2.4GHz ISM（Industry Science Medicine）是全世界公开通用使用的无线频段，蓝牙技术即工作在这一频段，在2.4GHz频段下工作可以获得更大的使用范围和更强的抗干扰能力，广泛应用于家用及商用领域。用于短距离无线传输和传导的技术。
2. 它是一个全球性的工作频段，开发的产品具有全球通用性 ，各种无线产品均可使用此频段，广泛用于个人穿戴设备及无线宽带路由器等室内场合。它整体的频宽胜于其他ISM 频段，这就提高了整体数据传输速率，允许系统共存，允许双向传输，且抗干扰性强，传输距离远（短距离无线技术范围）。
3. 2.4GHz无线电的天线的体积相当小，产品体积也更小，从而使芯片更集中，减少耗电。因2.4GHz无线技术的优势，各厂家不断推出新技术，也使此技术发展迅速。2.4G是一种无线技术，由于其频段处于2.400GHz~2.4835GHz之间，所以简称2.4G无线技术。是市面上三大主要无线技术（包括Bluetooth、27M、2.4G）之一。较普遍被应用于无线键盘鼠标。
4. 整合了高频键控（GFSK）收发电路的功能，以特小体积实现高速数据传输的功能。其中内含先进先出(FIFO)。可用于工业数据传输，无线遥控，无线鼠标，无线键盘，无线电子标签，遥控玩具，2.4g无线扩音器，无线麦克风，无线音箱等。自动化数据采集系统；工业无线控制；水、气、热、电等居民计量表具无线远传自动抄表。

#### 315M、433M、2.4G无线模块比较

（国内很多厂家开发的无线模块关键集中在315MHz、433MHz、2.4GHz这三个频点）

1. 315M、433M、2.4G无线模块的差别是频段不同，315M无线模块的频率是315MHz, 433M无线模块的频率是433MHz, 2.4G无线模块的频率是2400MHz。
2. 315M的波长比433的长些，天线也比433的长些，方向性没有433M的强，当它的绕性好，315M的穿透能力比433M的弱些。
3. 2.4G模块型号传输距离短，(一般10~30米，确实通讯距离10米)，传输进程衰减大，信号穿透、绕射能力弱，信号轻易被物体遮挡。433M无线模块信号强，传输距离长、穿透、绕射能力强，传输进程衰减减小。
4. 433MHz频段关键针对中国，东南亚，南美和东欧地区，在国内，一般更好使用430~440MHz，433.92MHz是最普遍的，配套产品齐全。而868MHz无线模块在国内不太适用，它关键是针对欧洲和北美等地区使用的。

#### 红外技术和射频技术

1. **红外技术的产品有方向性，发射器必须对准接收器，并且中间不能有阻挡物。距离一般不超过7米、不受电磁干扰,红外类产品的优势是产品成本低、价格便宜**。
2. 采用射频技术的产品是用无线电波来传送控制信号的，它的特点没有方向性，可以不“面对面”控制、距离远，可达数十米。发射器和接收器之间只要没有能起屏蔽作用的金属阻挡物，就可正常使用。**射频技术的产品成本通常要高一些，但其无方向性，使用更方便，所以更受用户的欢迎。**

#### zigbee

1. ZigBee，也称紫蜂，是一种低速短距离传输的无线网上协议，底层是采用IEEE 802.15.4标准规范的媒体访问层与物理层。**主要特色有低速、低耗电、低成本、支持大量网上节点、支持多种网上拓扑、低复杂度、快速、可靠、安全。**
2. ZigBee是一种新兴的短距离、低速率、低功耗无线网络技术，它是一种介于无线标记技术和蓝 牙之间的技术提案。ZigBee此前被称作“HomeRF Lite”或“FireFly”无线技术，主要用于近距离无线连接。它有自己的无线电标准，在数千个微小的传感器之间相互协调实现通信。这些传感器只需要很低的功耗，以接力的方式通过无线电波将数据从一个传感器传到另一个传感器，因此它们的通信效率非常高。最后，这些数据就可以进入计算机用 于分析或者被另外一种无线技术如wiMax收集。
3. **ZigBee的目标市场主要有PC外设(鼠标、键盘、游戏操控杆)、消费类电子设备(TV、VCR、CD、VCD、DVD等设备上的遥控装置)、家庭内智能控制(照明、煤气计量控制及报警等)、玩具(电子宠物)、医护(监视器和传感器)、工控(监视器、传感器和自动控制设备)等非常广阔的领域。**
4. **ZigBee技术的先天性优势，使得它在物联网行业逐渐成为一个主流技术，在工业、农业、智能 家居等领域得到大规模的应用。**例如，它可用于厂房内进行设备控制、采集粉尘和有毒气体等数据；在农业，可以实现温湿度、PH值等数据的采集并根据数据分析的结果进行灌溉、通风等联动动作；在矿井，可实现环境检测、语音通讯和人员位置定位等功能。
5. 315M、433M、2.4G、SUB-GHZ都是属于频段，而且315M、433M都是属于SUB-GHZ里面的一个频段。 **ZigBee模块是属于2.4GHZ里面的一个技术频段，在2.4G频段下还有Wi-Fi跟蓝牙。**

#### Wifi中的2.4G和5G

1. 5G通信跟5Ghz Wi-Fi 并不是一回事，5G通信实际上是 5th Generation mobile networks（第五代移动网络）的简称，主要是指蜂窝移动通信技术，而这里的5G指的WiFi标准中的5GHz，是指采用了5GHz频段传输数据的WiFi信号。
2. **生活中有很多电子设备都采用了2.4GHz的无线频率，比如微波炉、蓝牙设备**等，它们多多少少会有一些干扰2.4GHz的Wi-FI，使信号受到一定程度的影响。而5GHz的WiFi使用更高的频段带来了更少的信道拥堵，它使用了22个信道，并且彼此之间相互并不干扰，相对于2.4GHz的3个信道，明显减少了信号的拥堵。所以5GHz的传输速率是5GHz要比2.4GHz要快。不过，5GHz Wi-Fi也有缺点，它的缺点在于传输距离和穿越障碍物能力。
3. **2.4G传输距离远，速率低。5G传输距离近，速率高。**

#### 总结

| **射频**     | **315M** | **433M**                                                 | **2.4G**                                   |
| ------------ | -------- | -------------------------------------------------------- | ------------------------------------------ |
| **频段**     | 315MHz   | 433MHz                                                   | 2400MHz                                    |
| **传输速率** | ---      | 慢，由于受带宽和调制方式的限制                           | 快，频带宽和调制方式灵活的优势             |
| **绕射能力** | 强       | 比较强，可以用在相对比较复杂的环境                       | 较弱，常用于路由器方式                     |
| **通讯距离** | ---      | 同等参数下，点间距通讯距离更远                           | 同等参数下，点间距通讯距离较近             |
| **穿透能力** | 弱       | 穿透能力机较弱，信号的反射比较严重                       | 穿透能力比较强                             |
| **组网难度** | ---      | 比较难，目前没有开放的成熟的方案                         | 容易，已有现成的协议和案例                 |
| **灵敏度**   | ---      | 比较高，接收机带宽窄噪声小                               | 相对较低，接收机带宽宽噪声高               |
| **应用场景** | ---      | 数据传输量较小的应用场所：门禁、遥控、智能家居、机器人等 | 距离近，数据传输量大：路由器、键鼠、遥控等 |
|              |          |                                                          |                                            |

 注：315M同433M，只是相对绕射能力更强，穿透能力更弱  

<img src="typorafile\315M.png" style="zoom: 67%;" />

#### 无线发射--SCT2260

通过拆解得到小车使用SCT2260无线发射芯片, 技术资料详见文件夹. 

![]( typorafile\SCT2260.png)

SCT2260 功能:

1. 每一帧码有25位, 每一位码的码形有两种, 称为"0"和"1". 如图所示. 每一位的机时为4t. 
2. 每一帧码之所以有25位, 是因为总共有(A0,A1,...,A7,D3,D2,D1,D0)这12个管脚和最后一位结束位, 记为syn. 其中每个管脚Ai/Di 有三种可能的状态:高电平态(1), 低电平态(0), 悬空态(f), 这样也就需要2位数据来编码管脚状态. 具体来说, 高电平--11, 低电平--00, 悬空态--01. 
3. 解码端的地址码(A0~A7)必须和发码端相同才能解码.
4. syn是一个四位"0"码, 和后面28t的低电平组成同步头.



#### 无线接收--PT2272

接收部分与发射部分十分类似.I/O端口P0的P0^4~P0^7这四个引脚负责接收解码后的信号, 表示无线发射器四个按键是否被按下. 那么理论上会有$2^4=16$种组合方式. 比如, D0~D3为1000时表示只有第一个按键(A)按下, 为1100时表示两个按键(A+B)按下, 为1110时表示三个按键(A+B+C)按下, 以此类推. 只是多个按键一起按确实不方便, 所以以后如果可以, 建议使用更高端的无线传输方式. 

无线接收部分比红外接收部分更为简单, 因为有PT2272模块负责解码. 而红外部分则需要针对IR红外电阻和单片机中断系统进行控制解码.

### 蓝牙

<img src="E:\OneDrive - USTC\阅读\AI car\typorafile\blutooth.png" style="zoom:60%;" />

我们使用博通公司生产的BK3432芯片. BK3432是一个高度集成的5.0双模蓝牙数据SoC芯片，支持2mbps数据速率。它集成了高性能的射频收发器、基带、单片机、功能丰富的外设单元、可编程的协议和配置文件，支持蓝牙经典和低能耗应用。内置Flash架构使它适合于定制的应用程序。

| 特性                                                         |      |
| :----------------------------------------------------------- | ---- |
| 1.蓝牙®SIG蓝牙双模5.0                                        |      |
| 2.低功耗2.4 GHZ收发器                                        |      |
| 3.单片机集成                                                 |      |
| 4.160 KB可编程闪存用于程序，20KB RAM用于数据                 |      |
| 5.程序代码读保护                                             |      |
| 6.工作电压从0.9 V到3.6 V                                     |      |
| 7.时钟 (1)16MHz晶体基准时钟 (2)64MHz数字锁相环时钟 (3)32KHz环形振荡器 (4)外部32KHz晶体振荡器 (5)单片机可以运行在任何带有内部分频器的时钟源上 |      |
| 8.接口和外围设备 (1)JTAG, I2C, SPI接口 (2)两组UART接口 (3)多路PWM输出 (4)片上10位通用ADC (5)具有多路复用接口功能的GPIO (6)真随机数发生器 |      |
| 9.典型的封装类型 32-pin QFN 4x4                              |      |

BK3432蓝牙模块有4条线定义：VCC, GND, TDX, RXD, 分别表示电源线, 地线, 发送位, 接收位. 蓝牙调试有以下几个步骤:

#### 测试蓝牙模块

检测蓝牙模块是否正常. 蓝牙有两种模式: 配置模式和工作模式. 

1. **配置模式**：用来设置主从机、波特率、密码、连接等一系列信息（使用AT指令）；其中需要我们设置的是波特率，主从机以及密码。其具有断电保存的功能，所以我们一般只需要配置一次。
2. **工作模式**：当设置完配置模式一系列参数后，我们便可以进入正常模式，将蓝牙模块和另一个拥有蓝牙模块的设备进行通信，从而传递数据

首先把蓝牙模块连接到51单片机上. 此时我们需要进入蓝牙模块的配置模式进行检测蓝牙模块是否正常，顺便做一下个性化设置！

首先要熟悉HC05的三种状态，以及如何根据指示灯判断这些状态

1. 未连接配对状态：LED每一秒闪烁两次
2. 已连接配对状态：LED隔一秒闪烁两次
3. AT指令模式：LED每两秒闪烁一次

进入配置模式: 将主板通过USB线连接到电脑上(**注意：此时主板电源要关闭!**)按住蓝牙模块上的小按钮然后打开主板电源，直到蓝牙模块的指示灯两秒闪烁一次，现在就进入了蓝牙模块的配置模式！

下面我们分别从HC-05有按键的和无按键的蓝牙模块分别说明如何进行调试模式.

#### HC-05 with key

进入AT模式的方式: 按住key键接入计算机, 等到红蓝两个LED灯两秒一闪(只有红色LED亮), 就进入了AT指令模式. AT指令默认模式的波特率为38400, 数据位8, 检验位None, 停止位1. 打开串口即可输入相应命令测试.

指令的详细说明如下:

| 指令                            | 响应                                             | 参数                                                         | 作用                               |
| ------------------------------- | ------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------- |
| AT                              | OK                                               | -                                                            | 测试指令                           |
| AT+RESET                        | OK                                               | -                                                            | 模块复位                           |
| AT+VERSION?                     | +VERSION:<Param>OK                               | 软件版本号                                                   | 获取软件版本号                     |
| AT+ORGL                         | OK                                               | -                                                            | 恢复默认状态                       |
| AT+ADDR?                        | +ADDR:<Param>OK                                  | 模块蓝牙地址                                                 | 获取蓝牙地址                       |
| AT+NAME?                        | +NAME:<Param>OK--成功<br />FAIL--失败            | 蓝牙设备名称                                                 | 查询设备名称                       |
| AT+NAME=<Param>                 | OK                                               | 蓝牙设备名称                                                 | 设置设备名称                       |
| AT+RNAME?<Param1>               | 1.+NAME:<Param2>OK--成功<br />2.FAIL--失败       | Param1:远程蓝牙设备地址<br />Param2:远程蓝牙设备名称         | 获取远程蓝牙设备名称               |
| AT+ROLE=<Param><br />AT+ROLE?   | OK<br />+ROLE:<Param>OK                          | 参数取值为0:slave(默认),1:master 2:Slave-loop(回环角色)      | 查询设置模块角色                   |
| AT+CLASS=<Param><br />AT+CLASS? | OK<br />1.+CLASS:<Param> OK<br />2.FAIL          | Param: 设备类, 32位的参数, 用于指出设备类型以及所支持的服务类型. 默认值:1F00 | 设置/查询-设备类                   |
| AT+IAC=<Param><br />AT+IAC?     | 1.OK--成功<br />2.FAIL--失败<br />+IAC:<Param>OK | Param: 查询访问码. 默认值: 9e8b33.                           | 设置/查询-查询访问码               |
| AT+INQM=<P1>,<P2>,<P3>          | 1.OK--成功<br />2.FAIL--失败                     | P1: 查询模式, 0-inquiry_mode_standard, 1-inquiry_mode_rssi<br />P2: 最多蓝牙设备响应数<br />P3: 最大查询超时(1~48, 折合时间1.28s~61.44s),<br />默认值: 1,1,30 | 设置-查询访问模式                  |
| AT+INQM?                        | +INQM: <P1>,<P2>,<P3> OK                         | 同上. inquiry_mode_rssi表示带RSSI信号强度指示的查询模式.     | 查询-查询访问模式                  |
| AT+PSWD=<Param>                 | OK                                               | Param: 配对码                                                | 设置-配对码                        |
| AT+PSWD?                        | +PSWD: <Param> OK                                | 默认值: 1234                                                 | 查询-配对码                        |
| AT+UART=<P1>,<P2>,<P3>          | OK                                               | P1: 波特率; P2: 停止位,0--1位, 1--2位; P3: 校验位, 0--None, 1--Odd, 2--Even.<br />默认值: 9600, 0, 0 | 设置-串口参数                      |
| AT+UART?                        | +UART=<P1>,<P2>,<P3> OK                          | 同上                                                         | 查询-串口参数                      |
| AT+CMODE=<Param>                | OK                                               | Param: 0--指定蓝牙地址连接模式(指定蓝牙地址由绑定指令设置); 1--任意蓝牙地址连接模式 (不受绑定指令设置地址的约束); 2--回环角色(Slave-Loop)<br />默认连接模式: 0 | 设置-连接模式                      |
| AT+CMODE?                       | +CMODE:<Param> OK                                | 同上                                                         | 查询-连接模式                      |
| AT+BIND=<Param>                 | OK                                               | Param: 绑定蓝牙地址<br />默认绑定地址: 00:00:00:00:00:00     | 设置-绑定蓝牙地址                  |
| AT+BIND?                        | +BIND:<Param> OK                                 | 同上                                                         | 查询-绑定蓝牙地址                  |
| AT+POLAR=<P1>,<P2>              | OK                                               | P1: 0--PI08 输出低电平点亮LED; 1--PI08 输出高电平点亮LED; <br />P2: 0--PI09 输出低电平指示连接成功; 1--PI09 输出高电平指示连接成功<br />默认设置: 1,1 | 设置-LED指示驱动及连接状态输出极性 |
| AT+POLAR?                       | +POLAR=<P1>,<P2> OK                              | 同上. HC-05 蓝牙模块定义：PI08 输出驱动 LED 指示工作状态；PI09 输出指示连接状态。 | 查询-LED指示驱动及连接状态输出极性 |
| AT+PIO=<P1>,<P2>                | OK                                               | P1: PIO端口序列号(十进制)<br />P2: PIO端口输出状态, 0--低电平, 1--高电平 | 设置PIO单端口输出                  |
| AT+MPIO=<Param>                 | OK                                               | Param: PIO端口序号掩码组合(十进制).                          | 设置PIO多个多端口输出              |
| AT+MPIO?                        | +MPIO:<Param>OK                                  | Param--PIO端口值(16bits)<br />Param[0]=PIO0<br />...<br />Param[11]=PIO11 | 查询PIO端口输入                    |
| AT+IPSCAN=<P1>,<P2>,<P3>,<P4>   | OK                                               | P1: 查询时间间隔<br />P2: 查询持续时间<br />P3: 寻呼时间间隔<br />P4: 寻呼持续时间<br />上述参数均为十进制数.<br />默认值: 1024, 512, 1024, 512 | 设置-寻呼扫描, 查询扫描参数        |
| AT+IPSCAN?                      | +IPSCAN=<P1>,<P2>,<P3>,<P4> OK                   | 同上                                                         | 查询-寻呼扫描, 查询扫描参数        |
| AT+SNIFF=<P1>,<P2>,<P3>,<P4>    | OK                                               | P1: 最大时间<br />P2: 最小时间<br />P3: 尝试时间<br />P4: 超时时间<br />上述参数均为十进制数.<br />默认值: 0,0,0,0 | 设置-                              |
| AT+SNIFF?                       | +SNIFF=<P1>,<P2>,<P3>,<P4> OK                    | 同上                                                         | 查询-SNIFF节能参数                 |
| AT+SENM=<P1>,<P2>               | 1. OK--成功<br />2.FAIL--失败                    | P1: 安全模式，取值如下： <br />0--sec_mode0+off <br />1--sec_mode1+non_secure <br />2--sec_mode2_service <br />3--sec_mode3_link <br />4--sec_mode_unknown <br />P2: 加密模式，取值如下： <br />0--hci_enc_mode_off <br />1--hci_enc_mode_pt_to_pt <br />2--hci_enc_mode_pt_to_pt_and_bcast <br />默认值： 0,0 | 设置-安全, 加密模式                |
| AT+SENM?                        | +SENM=<P1>,<P2>, OK                              | 同上                                                         | 查询-安全, 加密模式                |
|                                 |                                                  |                                                              |                                    |
|                                 |                                                  |                                                              |                                    |

注意:

1. AT指令不区分大小写, 均以换行回车结束, 也就是AT换一行输入回车, 再点击发送指令, 才是有效的.
2. 我们注意到, 成功的指令发送时, USB转ttl串口的TXD和RXD端的LED都会同时闪烁一次, 但是无返回值的指令只有TXD对应的LED会闪烁.
3. 蓝牙模块默认状态:
   1. 设备类: 0
   2. 查询码: 0x009e8b33
   3. 模块工作角色: Slave mode
   4. 链接模式: 指定专用蓝牙设备连接模式
   5. 串口参数: 波特率--38400bit/s(不一定, 需要试一下)
   6. 配对码: 1234
   7. 设备名称: "HC-05"
4. 蓝牙地址格式为: (NAP: UAP: LAP). 第一段NAP是前面4个字节(前面位为0不显示), 第二段UAP是中间2个字节(前面位为0不显示), 第三段LAP是后面6个字节(前面位为0也显示).
5. 访问码设置为 GIAC（General Inquire Access Code:0x9e8b33）通用查询访问码，可用来发现或被发现周围所有的蓝牙设备；为了能有效地在周围诸多蓝牙设备中快速查询或被查询自定义蓝牙设备，用户可以将模块查询访问码设置成 GIAC 和 LIAC 以外的数字，如： 9e8b3f  
6. HC-05 型蓝牙模块为用户提供 PIO 端口资源：PI02～PI07，用户可用来扩展输入、 输出端口。  

### Keil开发编程软件

Keil是一款流行的嵌入式系统开发软件，它由Keil Software公司开发，提供了一整套工具和环境，用于开发和调试各种嵌入式系统的软件。Keil支持多种微控制器体系结构，包括ARM、8051、C166、ST10等，因此被广泛应用于许多领域，如消费电子、汽车电子、医疗设备等。

Keil提供了多种功能强大的工具，包括编译器、调试器、仿真器、代码编辑器等。其中，编译器可以将高级语言代码转换为可执行的机器代码，调试器可以帮助开发者在硬件上调试和测试代码，仿真器可以模拟硬件环境，让开发者在没有硬件的情况下进行开发。

Keil还提供了许多例程和模板代码，方便开发者快速上手和开发。此外，Keil还提供了许多学习资源，如文档、教程和视频，帮助开发者了解如何使用Keil进行开发和调试。但Keil是一款付费商业软件, 而且智能在Windows平台上运行, 编译速度较慢. 尽管如此, 对于初学者来说, 其仍为嵌入式开发的不二选项.

以下是一些可替代Keil的同类产品：

1. IAR Embedded Workbench：IAR是一款广泛使用的嵌入式系统开发软件，支持多种体系结构，具有优秀的代码优化能力和强大的调试功能。

2. Eclipse：Eclipse是一款开源的集成开发环境，支持多种编程语言和体系结构，具有丰富的插件和开发工具，可以进行跨平台开发。

3. Code Composer Studio：Code Composer Studio是德州仪器（TI）推出的一款嵌入式系统开发软件，支持TI的多种体系结构，具有强大的代码优化和调试功能。

4. MPLAB X IDE：MPLAB X IDE是Microchip公司推出的一款嵌入式系统开发软件，支持PIC和dsPIC微控制器，具有强大的调试和仿真功能。

5. Atmel Studio：Atmel Studio是Atmel公司推出的一款嵌入式系统开发软件，支持Atmel AVR和SAM微控制器，具有丰富的代码库和开发工具。

这些软件都具有一定的优点和特点，开发者可以根据自己的需求和偏好选择合适的开发工具。

#### Keil-free版本的安装和使用

free版和试用版最大的区别在于可编译程序的长度. 前者比后者要大很多.

安装Keil之后在`文件`->`License Management(授权管理)`->`Single-User License`中找到`Computer ID`, 复制. 然后打开注册补丁软件(先解压成.exe文件, 打开注册机, 这里注册机的作用是产生虚拟的注册序列号, 来使Keil达到破解的目的), 然后粘贴刚刚复制的`Computer ID`, 点击`Generate`生成注册序列号, 再次复制, 粘贴序列号至授权管理页面的`New License ID Code(LIC)`一栏中, 点击 `Add LIC`如果提示添加成功就可以使用free版了.

注意: 都要以管理员身份运行!!!

#### Keil里找不到AT89C52

因为Keil软件里面没有自带STC系列的单片机库；要想keil有STC单片机库，可以去STC官网去下载文件，安装到keil里面；如果你只是采用兼容的51系列单片机，那么你直接选atmel的就行，兼容的。

### 头文件定义

我们的思路是先学习已有的程序, 再根据我们的需求进行创造. 当我们打开任意一个Keil开发工程的时候, 我们一般会发现有两个头文件. 一个是系统的AT89X52.H文件, 另一个是用户自定义的头文件. 我们分别对着两种头文件进行介绍.

#### AT89X52.H头文件

AT89X52.H是Keil C51编译器的头文件之一，用于定义AT89X52单片机的寄存器和位字段。AT89X52.H文件可以分为以下几个模块：

1. 特殊功能寄存器（SFR）模块：该模块定义了AT89X52单片机的所有特殊功能寄存器，包括P0、P1、P2、P3、PSW、ACC、B、SP、DPL、DPH、PCON、SCON、TMOD、TL0、TL1、TH0、TH1等寄存器。

2. 位字段（Bit Fields）模块：该模块定义了AT89X52单片机中各个寄存器的位字段，例如P0口的各个引脚、PSW寄存器的各个位、SCON寄存器的各个位等。

3. 中断向量表模块：该模块定义了AT89X52单片机的中断向量表，包括外部中断0、外部中断1、定时器0中断、定时器1中断、串口中断等中断。

4. 特殊功能寄存器位定义模块：该模块定义了AT89X52单片机中一些特殊功能寄存器的位定义，如PSW寄存器的OV、AC、F0、RS0、RS1、P等位。

5. 定义常量和宏模块：该模块定义了一些常量和宏，如定义了AT89X52单片机的时钟频率、定义了一些特殊功能寄存器的地址、定义了一些常用宏等。

6. 定义函数模块：该模块定义了一些常用的函数，如延时函数、读写Flash函数、读写EEPROM函数等。

以上是AT89X52.H文件中的主要定义模块。开发者可以根据具体的应用需求，选择使用相应的模块，以便更好地访问和控制AT89X52单片机的寄存器和位字段。

下面详细介绍这些模块:

```c
/*--------------------------------------------------------------------------
AT89X52.H

Header file for the low voltage Flash Atmel AT89C52 and AT89LV52.
Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
All rights reserved.
--------------------------------------------------------------------------*/

#ifndef __AT89X52_H__
#define __AT89X52_H__
//防止该头文件被重复引用, 意思是**“if not define a.h”** 如果不存在a.h 就引入a.h
/*------------------------------------------------
Byte Registers
------------------------------------------------*/
sfr P0      = 0x80;
sfr SP      = 0x81;
sfr DPL     = 0x82;
sfr DPH     = 0x83;
sfr PCON    = 0x87;
sfr TCON    = 0x88;
sfr TMOD    = 0x89;
sfr TL0     = 0x8A;
sfr TL1     = 0x8B;
sfr TH0     = 0x8C;
sfr TH1     = 0x8D;
sfr P1      = 0x90;
sfr SCON    = 0x98;
sfr SBUF    = 0x99;
sfr P2      = 0xA0;
sfr IE      = 0xA8;
sfr P3      = 0xB0;
sfr IP      = 0xB8;
sfr T2CON   = 0xC8;
sfr T2MOD   = 0xC9;
sfr RCAP2L  = 0xCA;
sfr RCAP2H  = 0xCB;
sfr TL2     = 0xCC;
sfr TH2     = 0xCD;
sfr PSW     = 0xD0;
sfr ACC     = 0xE0;
sfr B       = 0xF0;

```

MCS: micro-control-system

51/52系列单片机片内有21/26个特殊功能寄存器。特殊功能寄存器（SFR，Special Function Register），又称专用寄存器，位于80H~FFH，但仅有21个字节（MCS-51系列）或26个字节（MCS-52子系列）作为SFR离散分布在这128个字节范围内，每个字节对应一个SFR。其余字节无定义，用户不能对这些单元进行读/写操作。26个SFR中，有12个的地址可被8整除，支持位寻址（bit-addressable）。 

sfr相当于定义了常量指针指向固定的地址值. 例如`sfr P0  = 0x80` 表示P0这个名称(指针)永远指向了`0x80`这个地址值. sbit定义常量指针指向某一位, 常见有两种方式: 

- sbit led = 0xA0^1; //A0是P2这个寄存器的地址
- sbit led2 =P2^0; //P2寄存器的名字

其中`^` 是异或运算,即`A0^1=1010 0000 XOR 0001=1010 0001`, 

```c
/*------------------------------------------------
P0 Bit Registers
------------------------------------------------*/
sbit P0_0 = 0x80;
sbit P0_1 = 0x81;
sbit P0_2 = 0x82;
sbit P0_3 = 0x83;
sbit P0_4 = 0x84;
sbit P0_5 = 0x85;
sbit P0_6 = 0x86;
sbit P0_7 = 0x87;
```

在定义sbit时我们可能会发现, `sbit P0_1 = 0x81` 不是和特殊寄存器SP重叠了吗? 因为 `sfr SP = 0x81`! 实际上并不是, 因为一个是寄存器地址, 一个是位地址. 此`0x81`非彼`0x81`! 寄存器地址与位地址的详细关系可以参照第五章51单片机的寄存器这一节.

### 驱动安装

#### CH340芯片

CH340是一款USB转串口芯片，它的作用是将计算机的USB接口转换为串口，使得计算机可以通过USB接口与其他串口设备进行通信。CH340芯片广泛应用于单片机开发板、串口设备等领域，它的出现极大地方便了开发者对于串口设备的使用。

为了使计算机能够识别和与CH340芯片进行通信，需要安装相应的驱动程序。驱动程序将CH340芯片所采集的串口数据转换为计算机可以识别的数据格式，并将计算机发送的数据转换为串口设备可以识别的数据格式。因此，安装CH340驱动程序是使用CH340芯片的前提条件。

#### 驱动程序

驱动程序在计算机系统中的作用是将硬件设备与操作系统进行连接和交互。驱动程序是一种软件，它可以将操作系统发送给硬件设备的指令进行转换，使得硬件设备能够按照指令进行工作，并将设备反馈的信息转换为计算机可以理解的格式，以便操作系统进行处理和分析。

对于CH340芯片这样的USB转串口芯片，驱动程序的作用是将从串口设备采集到的数据转换为计算机可以识别的数据格式，并将计算机发送的数据转换为串口设备可以识别的数据格式。这样，计算机就可以通过USB接口与串口设备进行通信，并实现数据的传输和控制。

CH341ser是南京沁恒微电子公司提供支持CH340芯片和CH341芯片的驱动程序. 安装之后, 在连接电脑的情况下, `此电脑` 右键-> `管理 `-> `设备管理器` -> `端口`, 可以看到CH340端口.

### 烧录

烧录也需要有相应的烧录软件. 这里使用 stc-isp-15xx烧录软件. 运行软件, 单片机型号选择**STC89C52RC/LE52RC**. **一定要选择正确的串口**. 点击 `打开程序文件` , 找到相应的debug好的项目文件夹中的 `.hex` 文件, 然后点击 `下载/编程`, 注意这时候小车电源是关闭的, 打开开关, 可以看到下载页面是滚动的, 下载结束时会有提示音. 然后就可以运行小车了. 

## 五. 51单片机

### 基本构成

51单片机通常由以下几个部分构成：

1. CPU：中央处理器，控制单元和算术逻辑单元组成，用于执行指令和处理数据。

2. 存储器：包括程序存储器（ROM）和数据存储器（RAM），用于存储程序和数据。

3. I/O口：输入输出口，可以用来连接各种外设，如LED、LCD、键盘、传感器等。

4. 定时器/计数器：可以用来生成定时和计数信号，实现各种定时、计数和脉冲宽度调制等功能。

5. 串行通信接口：可以用来进行串行通信，如UART、SPI、I2C等。

6. 中断控制器：可以响应外部中断请求，实现中断处理功能。

7. 看门狗定时器：用于监测程序是否运行正常，如果程序出现异常，看门狗定时器会自动复位单片机。

8. 器件引脚：单片机的各种信号和电源引脚，用于连接单片机和外部电路。

以上是51单片机的主要构成部分，不同的型号和厂家可能有所差异。

![]( typorafile\at89c51.PNG)

#### CPU

CPU 是单片机的核心部分， 是单片机的指挥和执行机构。 AT89C51 是 8 位单片机， CPU
的各种运算和操作都是以单字节 8 位为基础进行的。 从功能上看， CPU 包括两个基本部分：
运算器和控制器。
（1） 运算器
运算器即算术逻辑运算单元 （Arithmetic Logic Unit， ALU）， 是进行算术或逻辑运算的部件， 可以对单字节 （8 位） 数据进行操作。 例如可实现加、 减、 乘、 除等算术运算和与、或、 异或、 取反、 移位等逻辑运算。 操作的结果一般送回累加器 （ Accumulator， ACC）， 而其状态信息送至程序状态寄存器 （Program Status Word， PSW）。  

（2） 控制器
控制器是用来控制单片机工作的部件。 控制器接收来自存储器的指令， 进行译码， 并通过定时和控制电路， 在规定时刻发出指令所需的各种控制信息和 CPU 外部所需的各种控制信号， 使各部分协调工作， 完成指令所规定的操作。  

#### 内部数据存储器

AT89C51 芯片内共有 256 B （地址为： 00H ～ FFH） 的数据存储器， 其中高 128 B （地址为： 80H ～ FFH） 被专用寄存器 SFR 占用， 能作为存储器供用户使用的只是低 128 B （地址为： 00H ～ 7FH）， 用于存放可读写的数据， 如程序执行过程中的变量等。  

#### 内部程序存储器

AT89C51 共有 4 KB （地址为： 0000H ～ 0FFFH） 的 Flash 程序存储器， 用于存放程序、原始数据或表格常数。  

#### 定时/ 计数器

AT89C51 共有两个 16 位的定时/ 计数器， 每个定时/ 计数器都可以设置成计数方式， 用于对外部事件进行计数； 也可以设置成定时方式， 并可以根据计数或定时的结果实现对单片机运行的控制。  

#### 并行 I / O 口

AT89C51 共有 4 个 8 位的 I / O 口 （ P0、 Pl、 P2、 P3）。 每个 8 位的口， 既可用作输入口， 也可用作输出口， 每个口既可以 8 位同步读写， 又可对每一位进行单独的操作， 十分方便  

#### 串行口

AT89C51 单片机有一个全双工的串行接口， 实现单片机和其他设备之间的串行数据交换。 该串行口功能较强， 既可作为全双工异步通信使用， 也可作为同步移位器使用。  

#### 中断控制系统

AT89C51 单片机有较强的中断系统， 可以满足控制应用的需要。 AT89C51 的中断系统有 5 个中断源， 包括两个外中断、 两个定时/ 计数中断和一个串行口中断。 

#### 时钟电路

AT89C51 芯片的内部有时钟电路， 但石英晶体和微调电容需外接。 时钟电路为单片机产生时钟脉冲序列。

### 单片机存储器

### ![]( typorafile\Mem.PNG)   

#### 程序存储器

#### 数据存储器

![](typorafile\ram.PNG)

AT89C51数据存储器大体分为两部分。 低 128 B （低 128 字节） 的数据存储器区和高 128 B （高 128 字节） 的特殊功能寄存器区， 用 8 位地址寻址， 共 256 个 B. 

 低 128 B 的数据存储器 （地址范围： 00H ～ 7FH） 用于存放程序运算的中间结果， 以及用作缓存、 堆栈等。 低 128 B 的数据存储器的存储器配置如图所示， 分为三个区域， 即工作寄存器区、 位寻址区和用户 RAM 区。 地址 00 ～ 1FH 为通用寄存器区； 20H ～ 2FH 为位寻址区； 30H ～ 7FH 为用户 RAM 区。  

##### 工作寄存器区

通过程序对程序状态字 PSW 中的 RS1、 RS0 位进行设置， 以实现工作寄存器组的切换 

![]( typorafile\工作寄存器区.PNG)

##### 位寻址区

![]( typorafile\位地址.PNG)

字节地址和位地址都是用8 位的二进制表示， 理解上容易产生混淆。 字节地址单元的数据是 8 位二进制数， 而位地址的数据仅是 1 位二进制数。 

- 例如， 字节地址2AH 单元的数为 0， 表示位地址 50H ～ 57H 中 8 个单元的数均为 0，
-  又例如位地址 28H 的数为 0， 表示字节地址 25H 的 D0 位 （最低位） 为 0。 
- 也可以用 “字节地址 . 位” 表示位地址，例如 25H. 1 （字节地址 25H 的第 1 位 D1） 等于位地址 29H。  

##### 用户RAM

在 30H ～ 7FH 区的 80 个 RAM 单元为用户 RAM 区， 只能按字节存取。 由于工作寄存器区、 位寻址区、 数据缓冲区统一编址， 可使用同样的指令访问。 这三个区的单元既有自己独特的功能， 又可统一调度使用。   

### 单片机寄存器



![](typorafile\sfr.png)

8051 SFR分布:

![](typorafile\sfr8051.gif)

8052 SFR分布:

![](typorafile\sfr8052.gif)

绿色的寄存器是无法寻址的, 也就是用户不可控.

特殊功能寄存器反映了单片机的状态，是单片机的状态及控制字寄存器。可分为两类：

- 芯片内部功能的控制用寄存器：运算部件寄存器ACC、B、PSW、堆栈指针SP、数据指针DPTR、各种定时/计数器控制、中断控制、串行口控制等；
- 与芯片引脚有关的寄存器：P0、P1、P2、P3，它们实际上是4个锁存器，每个锁存器再附加上相应的一个输出驱动器和一个输入缓冲器就构成了一个并行口。

特殊功能寄存器地址表

![]( typorafile\sfradress1.PNG)

![]( typorafile\sfradress2.PNG)

##### 累加器ACC

Accumulator Register，应用最广泛的专用寄存器。许多单操作数指令的操作数、双操作数指令的一个操作数取自累加器。加、减、乘、除算术运算指令的结果都存放在累加器A或寄存器B中。累加器ACC的助记符是A，当对累加器的位进行操作时，常用符号是ACC，比如累加器第0位是“ACC.0”。

##### 寄存器B

B Register，用于乘除运算或作为一般寄存器。

- 乘：两个操作数一个是累加器A，另一个必须是寄存器B，结果存在A和B中；
- 除：被除数是累加器A，除数是寄存器B，商存在A中，余数存在B中。

##### 程序状态字PSW

Program State Word，存放着当前ALU的操作状态特征，其内部定义如下表。

![](typorafile\psw.png)

##### 堆栈及堆栈指针SP

Stack Pointer，堆栈的特点是“先进后出”，是为程序调用和中断操作而设立的，主要是保护断点和保护现场。单片机中，CPU无论是执行**子程序调用操作**还是执行**中断操作**，最终都要返回，因此需预先把**主程序的被中断的地方**（称为断点）保护起来，为正确返回做准备，实现保护现场的功能。为使CPU能进行多级中断嵌套及多重子程序调用，堆栈必须有足够容量。

堆栈指针SP，就是栈顶的存储单元地址。当堆栈无数据时，栈顶地址与栈底地址重合。51单片机的堆栈指针SP为8位寄存器，系统复位后，SP初值为07H，**实际应用中通常根据需要在主程序开始处对堆栈指针SP进行初始化，**一般在片内RAM的30H~7FH区域中开辟堆栈区，一般将SP设置为60H。

堆栈有向上生长型和向下生长型。MCS-51单片机的堆栈结构属于向上生长型，遵循“先加后压”规则：入栈时，先SP加1，然后数据写入栈；出栈时，先读出数据，再SP减1。

堆栈的使用方式有两种：

- 自动方式，在调用子程序或断点时，断点地址自动进入栈，程序返回时，断点地址再自动弹回PC，不需要用户干涉。
- 指令方式，使用专用的堆栈操作指令进行入、出栈操作。例如保护现场、恢复现场。需要保护的数据单元量由用户设定。



##### 数据指针DPTR

Data Pointer，既可是一个16位专用寄存器（DPTR），有16位数加“1”功能；也可拆开作为两个8位寄存器（高位字节寄存器DPH、低位字节寄存器DPL）。DPTR是继程序计数器（PC）以外的第二个16位寄存器，主要用途是保存16位地址信息，常用于基址加变址间接寄存器寻址方式使用，寻址片外64KB的数据存储器或程序存储器空间。



##### 端口寄存器P0~P3

专用寄存器P0~P3分别是I/O端口P0~P3的8位锁存器，均为可位寻址寄存器。



##### 定时/计数器TL0~TH1

51单片机有两个16位定时/计数器T0和T1，52比51多一个16位定时/计数器T2。它们都是由两个独立的8位寄存器TH和TL组成的16位寄存器。



##### 中断允许寄存器IE

Interrupt Enable Register，中断源请求后， 中断能否被响应， 取决于 CPU 对中断源的开放或屏蔽状态， 由内部的中断允许寄存器 IE 进行控制， IE 的地址是 A8H， 位地址为 A8H ～ AFH  。每一位对应不同的中断源，可设定为“允许(1)”或“禁止(0)”中断。单片机复位后会被清0。欲使某中断源允许中断，设置IE对应位的同时还必须设置IE中的最高位EA，使EA=1（CPU开放中断）。EA相当于中断允许的“总开关”。**注意EA位在第8位, 第6,7位没有定义.** 

<img src="typorafile\sfr_ie.png" style="zoom:67%;" />

##### 中断优先级寄存器IP

Interrupt Priority Register，字节地址为B8H。每一位对应不同的中断源，其复位清“0”会把对应中断源设置为低优先级中断；置“1”将把对应中断源设置为高优先级。例如要使T0中断的优先级高于外部中断请求0中断，可将PX0清“0”、PTO置“1”。单片机复位后会被清0。

<img src="typorafile\sfr_ip.png" style="zoom:50%;" />

##### 定时器工作方式寄存器TMOD

Timer Mode，D0~D3管理T0，D4~D7管理T1。工作方式控制寄存器 TMOD， 用来设定定时 / 计数器 T0、 T1 的工作方式。 TMOD 寄存器只能进行字节寻址， 地址为 89H， 不能进行位寻址， 即 TMOD 的内容， 只能通过字节传送指令进行赋值。   

<img src="typorafile\sfr_tmod.png" style="zoom:80%;" />

GATE： 门控位， GATE = 0， 作为定时器或者 T0 引脚上脉冲的计数器。 GATE = 1， 用于测量引脚INT0上脉冲的宽度。当 GATE = 1 时， 仅当 TR0 = 1 且INT0位于高电平时， 才能启动定时 / 计数器 0 工作. 在 GATE = 0 的情况下， T0 的启停由软件设置 TR0 实现。TR0 = 1： 启动定时/ 计数器 T0； TR0 = 1： 停止定时/ 计数器 T0 .

C / T： 定时器方式和计数器方式选择控制位。 通过软件设置 C / T， 实现定时或计数的功能选择。 当 C / T = 0， T0 作为定时器使用， 当 C / T = 1， T0 作为计数器使用， 计数外部引脚T0 上的脉冲。
M1M0： 工作方式控制位。 M1M0 对应 4 种不同的二进制组合， 分别对应 4 种工作方式。
M1M0 = 00： 工作方式 0， 13 位定时/ 计数器。
M1M0 = 01： 工作方式 1， 16 位定时/ 计数器， 常用的工作方式。
M1M0 = 10： 工作方式 2， 8 位定时/ 计数器， 常用的工作方式。
M1M0 = 11： 工作方式 3， 8 位定时/ 计数器。  

##### 定时器控制寄存器TCON

Timer Control Register，属于中断标志位寄存器。字节地址为88H，主要用来控制2个定时/计数器溢出中断标志及2个外部中断INT0和INT1请求标志。

![](typorafile\sfr_tcon.png)

##### 串行口控制寄存器SCON

Serial Control Register，属于中断标志位寄存器。字节地址为98H。与中断相关是SCON的低2位，用来锁存串行口的发送（Transmit）中断和接收（Receive）中断标志。

![](typorafile\sfr_scon.png)

##### 串行数据寄存器SBUF

Serial Buffer，用于串行通信，存放发送和接收数据。逻辑上是一个寄存器，物理上是两个寄存器：发送缓冲寄存器、接收缓冲寄存器，使用同一个逻辑地址，写入时SBUF指向发送数据缓冲器、读入时SBUF取自接收缓冲寄存器。

串行口对外有两条独立的收、发信号线：RXD和TXD，可以同时发送和接收数据，实现全双工传送。例：

<img src="typorafile\sfr_sbuf.png" style="zoom: 67%;" />

##### 电源控制寄存器PCON

Power Control Register，电源控制及波特率选择寄存器，字节地址为87H。

<img src="typorafile\sfr_pcon.png" style="zoom:80%;" />

## 单片机C语言编程

### 简单功能实现

#### 时钟周期与delay函数

在单片机中，每步指令的周期（也称为指令周期）是指执行一条指令所需的时间。该时间取决于单片机的时钟频率和指令的执行时间。 

以STC89C52单片机为例，假设时钟频率为$f_{clk}$，则每步指令的周期可以计算为：

$$
T_{cycle} = \frac{1}{f_{clk}} \times 12
$$
其中，因为STC89C52单片机的指令周期是12个时钟周期，所以需要乘以12。这个公式的含义是将时钟频率转换为周期时间，再乘以12得到每步指令的周期时间。 

例如，如果STC89C52单片机的时钟频率为11.0592MHz，则每步指令的周期(假设一个指令周期包含一个机器周期)为：

$$
T_{cycle} = \frac{1}{11.0592 \times 10^6} \times 12 \approx 1.085 \mu s
$$
需要注意的是，上述公式仅适用于指令执行时间固定的单片机。如果单片机中存在多种指令，每条指令的执行时间不同，则需要根据具体情况进行计算。

##### 晶振频率和时钟频率

STC89C52单片机的晶振频率和时钟频率是不同的。晶振频率指的是连接到单片机晶振引脚的外部晶体的振荡频率，通常为11.0592MHz或12MHz。而时钟频率则是单片机内部时钟电路产生的时钟信号的频率，它由晶振频率经过分频器分频得到。

STC89C52单片机的时钟电路可以通过设置定时器/计数器的预分频器和计数器的值来实现不同的时钟频率。例如，当预分频器的值为12时，计数器的值为1，时钟频率为晶振频率除以**预分频器**和**计数器**的乘积，即11.0592MHz / 12 / 1 = 921.6kHz。当预分频器的值为1时，计数器的值为1，时钟频率为晶振频率除以预分频器和计数器的乘积，即11.0592MHz / 1 / 1 = 11.0592MHz。

需要注意的是，STC89C52单片机的时钟频率是固定的，无法在程序运行时动态修改。因此，在编写程序时需要根据实际需要选择合适的预分频器和计数器的值来设置合适的时钟频率。

![]( typorafile\oscillator.png)

如图所示, X1 是片内振荡器的反相放大器输入端， X2 则是输出端(其输入端引脚为19引脚XTAL1，其输出端引脚为18引脚XTAL2)，使用外部振荡器时，外部振荡信号应直接加到 X1，而 X2 悬空。内部方式时，时钟发生器对振荡脉冲二分频， 如晶振为 12MHz， 时钟频率就为 6MHz。晶振的频率可以在 1MHz-24MHz 内选择。电容取 30PF 左右。  

对于STC单片机，晶振频率范围一般是1.2MHZ~12MHZ，晶振频率越高，系统的时钟频率也越高，单片机的速度也就越快。通常情况下，使用晶振的频率为6MHZ或12MHZ。如果系统中使用了单片机的串口通信，则一般采用振荡频率为11.0592MHZ的晶振，它每秒振荡11059200次。

**注意:**

单片机是按照时序进行工作的，关于MCS-51系列单片机的时序概念有四个，可用定时单位来说明，从小到大依次是：节拍、状态、机器周期和指令周期。把振荡脉冲的周期定义为节拍，用P表示，也就是晶振的振荡频率Fosc。振荡脉冲Fosc经过二分频后，就是单片机时钟信号的周期，定义为状态，用S表示。一个状态包含两个节拍，其前半周期对应的节拍叫P1，后半周期对应的节拍叫P2。MCS-51系列单片机采用定时控制方式，有固定的机器周期。规定一个机器周期的宽度为6个状态，即12个振荡脉冲周期，因此机器周期就是振荡脉冲的十二分频。比如当振荡脉冲频率为12 MHz时, 一个机器周期为1µs；当振荡脉冲频率为6MHz时，一个机器周期为2  µs。指令周期是最大的时序定时单位，即执行一条指令所需要的时间。**它一般是由若干个机器周期组成**。不同指令，所需要的机器周期数也不同。通常包含一个机器周期的指令称为单周期指令，包含两个机器周期的指令称之为双周期指令，依次类推。另外需要注意的是这里的“指令”指的是**汇编指令**，而不是指的**C语言程序**。

![]( typorafile\oscillator3.png)

##### delay函数

C语言for循环精确延时示例:

 一. 500ms延时子程序

程序: 

```c
void delay500ms(void)
{	unsigned char i,j,k;
	for(i=15;i>0;i--)
        for(j=202;j>0;j--)
            for(k=81;k>0;k--);
}
```

产生的汇编:

```c
C:0x0800  7F0F   MOV   R7,#0x0F
C:0x0802  7ECA   MOV   R6,#0xCA
C:0x0804  7D51   MOV   R5,#0x51
C:0x0806  DDFE   DJNZ   R5,C:0806
C:0x0808  DEFA   DJNZ   R6,C:0804
C:0x080A  DFF6   DJNZ   R7,C:0802
C:0x080C  22    RET   
```

计算分析:

程序共有三层循环

一层循环n:R5*2 = 81*2 = 162us         DJNZ 2us

二层循环m:R6*(n+3) = 202*165 = 33330us     DJNZ 2us + R5赋值 1us = 3us

三层循环: R7*(m+3) = 15*33333 = 499995us    DJNZ 2us + R6赋值 1us = 3us

循环外:  5us      子程序调用 2us + 子程序返回 2us + R7赋值 1us = 5us

延时总时间 = 三层循环 + 循环外 = 499995+5 = 500000us =500ms

计算公式:     延时时间=[(2*R5+3)*R6+3]*R7+5

二. 200ms延时子程序

程序:

```c
void delay200ms(void)
{	unsigned char i,j,k;
	for(i=5;i>0;i--)
        for(j=132;j>0;j--)
            for(k=150;k>0;k--);
}
```

产生的汇编

```c
C:0x0800  7F05   MOV   R7,#0x05
C:0x0802  7E84   MOV   R6,#0x84
C:0x0804  7D96   MOV   R5,#0x96
C:0x0806  DDFE   DJNZ   R5,C:0806
C:0x0808  DEFA   DJNZ   R6,C:0804
C:0x080A  DFF6   DJNZ   R7,C:0802
C:0x080C  22    RET
```

 三. 10ms延时子程序

程序:

```c
void delay10ms(void)
{	unsigned char i,j,k;
	for(i=5;i>0;i--)
        for(j=4;j>0;j--)
            for(k=248;k>0;k--);
}
```

产生的汇编

```c
C:0x0800  7F05   MOV   R7,#0x05
C:0x0802  7E04   MOV   R6,#0x04
C:0x0804  7DF8   MOV   R5,#0xF8
C:0x0806  DDFE   DJNZ   R5,C:0806
C:0x0808  DEFA   DJNZ   R6,C:0804
C:0x080A  DFF6   DJNZ   R7,C:0802
C:0x080C  22    RET 
```

  四. 1s延时子程序

程序:

```c
void delay1s(void)
{	unsigned char h,i,j,k;
 	for(h=5;h>0;h--)
        for(i=4;i>0;i--)
            for(j=116;j>0;j--)
                for(k=214;k>0;k--);
}
```

产生的汇编

```c
C:0x0800  7F05   MOV   R7,#0x05
C:0x0802  7E04   MOV   R6,#0x04
C:0x0804  7D74   MOV   R5,#0x74
C:0x0806  7CD6   MOV   R4,#0xD6
C:0x0808  DCFE   DJNZ   R4,C:0808
C:0x080A  DDFA   DJNZ   R5,C:0806
C:0x080C  DEF6   DJNZ   R6,C:0804
C:0x080E  DFF2   DJNZ   R7,C:0802
C:0x0810  22    RET
```

在精确延时的计算当中,最容易让人忽略的是计算循环外的那部分延时,在对时间要求不高的场合,这部分对程序不会造成影响.

五. 精确延时种类及其计算

我们使用的单片机晶振频率为11.0592MHz, 由于采用内部时钟方式, 时钟频率就是晶振频率. 

下表是的所有变量的种类均为unsigned char.

| 循环种类 | for(n=0;N<I;N++) |  while(i--);  |  while(--i);  |
| :------: | :--------------: | :-----------: | :-----------: |
|   $0$    |      $2+7$       |      $9$      |     $--$      |
|   $1$    |     $2+8+7$      |     $6+9$     |     $2+2$     |
|   $2$    | $2+8\times 2+7$  | $6\times 2+9$ | $2\times 2+2$ |
| $\dots$  |     $\dots$      |    $\dots$    |    $\dots$    |
|   $i$    |      $8i+9$      |    $6i+9$     |    $2i+2$     |

反汇编分析: 以 for(n=0;n<i;n++);  为例.

```assembly
     6: void delay0 (unsigned char i)    
     7: {    unsigned char n;   
     8:      for(n=0;n<i;n++);    
C:0x0033    E4       CLR      A			//1T
C:0x0034    FE       MOV      R6,A		//1T

C:0x0035    EE       MOV      A,R6		//1T
C:0x0036    C3       CLR      C			//1T
C:0x0037    9F       SUBB     A,R7		//1T
C:0x0038    5003     JNC      C:003D	//2T
C:0x003A    0E       INC      R6		//1T
C:0x003B    80F8     SJMP     C:0035	//2T
     9: }   
C:0x003D    22       RET      //2T
```

可以看出，一共8条语句(不算返回命令)，分析语句可以发现并不是每条语句都执行DlyT次。核心循环只有0x0011~0x0017共6条语句，总共8个机器周期，第1次循环先执行“CLR A”和“MOV R6，A”两条语句，需要2个机器周期，每循环1次需要8个机器周期，但最后1次循环需要5个机器周期。核心循环语句消耗（2+DlyT×8+5）个机器周期，当系统采用12 MHz时，精度为7 μs。



再如:当采用while (i--)循环体时，MOV的操作数需要注意. 以及JNZ不成功跳转时需要三个机器周期.

```assembly
    11: void delay(unsigned char i)                  
    12: {                            
    13:   while(i--);                              
C:0x0053    AE07     MOV      R6,0x07		//2T
C:0x0055    1F       DEC      R7
C:0x0056    EE       MOV      A,R6			//1T
C:0x0057    70FA     JNZ      C:0053
    14: } 
C:0x0059    22       RET      
```

再如:当采用while (--i)循环体时, DJNZ无论是否跳转均为两个周期.

```assembly
C:0x001B    DFFE     DJNZ     R7,C:001B //2T
C:0x001D    22       RET          
```

```assembly
    56: void delayms(unsigned char x)                       
    57: { // 
    58:   unsigned char i; 
    59:   while(x--)  
    60:   { 
    61:     for (i = 0; i<13; i++) {}  
    62:   } 
C:0x024A    AD07     MOV      R5,0x07    //1T
C:0x024C    1F       DEC      R7		//1T
C:0x024D    ED       MOV      A,R5		//1T
C:0x024E    600B     JZ       C:025B	//2T

C:0x0250    E4       CLR      A			//1T
C:0x0251    FE       MOV      R6,A		//1T
C:0x0252    EE       MOV      A,R6		//1T
C:0x0253    C3       CLR      C			//1T
C:0x0254    940D     SUBB     A,#IRCOM(0x0D) //1T
C:0x0256    50F2     JNC      C:024A	//2T
C:0x0258    0E       INC      R6		//1T
C:0x0259    80F7     SJMP     C:0252	//2T
C:0x025B    22       RET   				//2T
```

所以当输入的x=1时, 上述代码所用机器周期为$[(2+8\times N_i+5)+5]\times x+ 5+2=123$个机器周期, 也就是$133.5\mu s$. 

注意上述内容是在x为unsigned char x基础上的, 如果用unsigned int x, 结果会很不一样. 

| 循环种类 | for(n=0;N<I;N++) |  while(i--);   |  while(--i);  |
| :------: | :--------------: | :------------: | :-----------: |
|   $0$    |      $3+9$       |      $12$      |      ---      |
|   $1$    |     $3+12+9$     |     $9+12$     |     $8+2$     |
|   $2$    | $3+12\times 2+9$ | $9\times 2+12$ | $8\times 2+2$ |
|   $i$    |    $12(i+1)$     |    $9i+12$     |    $8i+2$     |

注: while(--i)循环初值不能是i=0, 因为i是无符号整型变量, 在进行自减操作后, 寄存器 R7 的值会变为0xff, 这就导致了最大次数的循环而不是0次.(见后面汇编代码)

如图所示, while(--i)机器周期为$8i+2$. R6寄存器是当输入的值超过256时才会用到, 用来存储传参值的高8位, 只有当进位或借位时才会进行自减操作.

```assembly
    20: void delay3 (unsigned int i)
    21: {       
    22:  while(--i);    
C:0x0021    EF       MOV      A,R7		//1T
C:0x0022    1F       DEC      R7		//1T(i--操作)
C:0x0023    7001     JNZ      C:0026	//2T(A不为0时跳转)
C:0x0025    1E       DEC      R6		//1T(i>0时不执行)
C:0x0026    14       DEC      A			//1T
C:0x0027    4E       ORL      A,R6		//1T
C:0x0028    70F7     JNZ      C:0021	//2T(A不为0时跳转)
    23: }   
C:0x002A    22       RET      //2T
```

类似地, 有while(i--)的汇编代码:

```assembly
    25: void delay4 (unsigned int i)    
    26: {       
    27:  while(i--);    
C:0x0021    EF       MOV      A,R7		//1T
C:0x0022    1F       DEC      R7		//1T
C:0x0023    AC06     MOV      R4,0x06	//2T
C:0x0025    7001     JNZ      C:0028	//2T
C:0x0027    1E       DEC      R6		//1T(正常情况跳过)
C:0x0028    4C       ORL      A,R4		//1T
C:0x0029    70F6     JNZ      C:0021	//2T
    28: }   
C:0x002B    22       RET      //2T
```

 类似地, 有for(n=0;n<i;n++); 的汇编代码:

```assembly
    31: void delay5 (unsigned int i)    
    32: {    unsigned int n;   
    33:      for(n=0;n<i;n++);    
C:0x0003    E4       CLR      A			//1T
C:0x0004    FD       MOV      R5,A		//1T
C:0x0005    FC       MOV      R4,A		//1T

C:0x0006    C3       CLR      C			//1T
C:0x0007    ED       MOV      A,R5		//1T
C:0x0008    9F       SUBB     A,R7		//1T
C:0x0009    EC       MOV      A,R4		//1T
C:0x000A    9E       SUBB     A,R6		//1T
C:0x000B    5007     JNC      C:0014	//2T
C:0x000D    0D       INC      R5		//1T
C:0x000E    BD0001   CJNE     R5,#0x00,C:0012 //2T
C:0x0011    0C       INC      R4		//1T
C:0x0012    80F2     SJMP     C:0006	//2T
    34: }   
    
C:0x0014    22       RET      //2T
```





**注意常见指令的机器周期数**:

1. **MOV指令**：MOV指令的机器周期数为1个或2个。当MOV指令的**源操作数**和**目的操作数**都是寄存器时，只需要1个机器周期即可完成；当源操作数是寄存器，目的操作数是内存或者立即数时，需要2个机器周期。
2. **DEC指令**：DEC指令用于将寄存器或内存中的数据减1，机器周期数为1个。
3. **JNZ指令**：JNZ指令用于条件跳转，只有在寄存器或内存中的数据不为0时才会跳转，机器周期数为2个.
4. **ORL指令**：ORL指令用于将两个操作数按位或运算，机器周期数为1个或2个。当ORL指令的源操作数和目的操作数都是寄存器时，只需要1个机器周期即可完成；当源操作数是寄存器，目的操作数是内存或者立即数时，需要2个机器周期。
5. **JZ指令**：JZ指令用于条件跳转，只有在寄存器或内存中的数据为0时才会跳转，机器周期数为2个。
6. **CLR指令**：CLR指令用于将寄存器或内存中的数据清零，机器周期数为1个。
7. **SUBB指令**：SUBB指令用于将两个操作数相减，并将结果存储到目的操作数中，机器周期数为1个或2个。当SUBB指令的源操作数和目的操作数都是寄存器时，只需要1个机器周期即可完成；当源操作数是寄存器，目的操作数是内存或者立即数时，需要2个机器周期。
8. **JNC指令**：JNC指令用于条件跳转，只有在进位标志位为0时才会跳转，机器周期数为2个。
9. **INC指令**：INC指令用于将寄存器或内存中的数据加1，机器周期数为1个。
10. **SJMP指令**：SJMP指令用于无条件跳转，机器周期数为2个。
11. **JNCC指令**：JNCC指令用于条件跳转，只有在进位标志位为1时才会跳转，机器周期数为2个。
12. **SJMPC指令**：SJMPC指令用于无条件跳转，机器周期数为3个。
13. **RET指令**：RET指令用于返回子程序调用点，机器周期数为2个。
14. **CJNE 指令**: CJNE A, #data, rel：CJNE指令用于比较累加器A的值和立即数data的值，如果不相等则跳转到相对地址rel处。需要2个机器周期。
15. **DJNZ指令**: DJNZ @Rn,  rel：DJNZ指令用于将寄存器Rn所指向的内存单元的值减1，如果减1后不等于0则跳转到相对地址rel处。需要2个机器周期。

####  蜂鸣器

分为**压电式蜂鸣器**和**电磁式蜂鸣器**两种.

- **压电式蜂鸣器**通过压电材料和金属片两端施加上一个电压后，由于压电效应，蜂鸣片就会产生机械变形而发出声响。
- **电磁式蜂鸣器**按照其内部是否集成了**震荡源**可分为**有源蜂鸣器**和**无源蜂鸣器**，利用电磁线圈对蜂鸣片的作用来发声的电子响讯器。**有源蜂鸣器**由于内部集成了震荡源，在蜂鸣器上电后就会以一定的频率发出响声。而**无源蜂鸣器**则需要使用方波去驱动它。其有源蜂鸣器价格高于无源蜂鸣器。但无源蜂鸣器可控声音频率，达到一定程度的音乐盒效果。由于有源蜂鸣器和无源蜂鸣器的工作原理不同，它们的声音也有所不同。有源蜂鸣器的声音比较尖锐，音量较大，而无源蜂鸣器的声音比较柔和，音量较小。

我们经常使用的为有源式蜂鸣器(智能小车也是该类)，蜂鸣器作为电磁感性器件，其驱动需要较大的电流，而IO的输出电流能力有限，因此需要搭配外围电路对其进行控制，常见的方式有三极管。

![]( typorafile\buzz.PNG)

通过三极管的使得蜂鸣器工作，同时在蜂鸣器两端并联二极管，以保证在关断感性原件蜂鸣器时减小对电路的冲击。

网上有很多用蜂鸣器实现音乐盒的方法, 但是注意只限于无源蜂鸣器. 无源蜂鸣器由于频率固定是无法实现这个功能的.

#### 数码管

一个数码管是由a、b、c、d、e、f、g、dp八个二极管组成，八个LED一端接在一起，另一端引脚引出来。二极管如果阳极连在一起，就是共阳极数码管，阴极连在一起，就是共阴极数码管。

如上图，是一个共阴极数码管，要使数码管显示不同的数字，只需点亮对应LED即可。如：数码管显示“0”，则a、b、c、d、e、f六个LED亮，g、dp这俩个LED灭，即可显示“0”。
![]( typorafile\1位共阴数码管.jpg)

如果有六个数码管，在使用时，需要程序选定使用哪几个数码管，这就是“位选”，选定数码管后再对选定的数码管进行操作，其操作与单个数码管的操作一致（接下来还会进一步详解），这就是“段选”。

数码管与芯片的连接

为什么要使用锁存器？二极管正常工作时需要5mA以上的电流，若数码管引脚和芯片引脚直接相连，芯片的I/O口无法输出这么大的电流，对于共阴极的数码管，可以在阳极处接上拉电阻，对于共阳极的数码管，可以在阴极处接下拉电阻，但是也使得“位选”需做另外的处理。引入锁存器，利用其输出电流大的特点，有效的解决了LED工作电流问题，而且还可以利用锁存器进行“位选”、“段选”。


不用锁存器行不行? 行, 加个电阻.

![]( typorafile\数码管.png)

P00-P07控制的二极管分别为: DP, g,f,e,d,c,b,a. 也就是说a对应的是次低位的引脚, 由此可以得到数码管的显示数字, 用P0赋值来表示为: 

```c
uchar code table[]={
0x03,0x9f,0x25,0x0d,
0x99,0x49,0x41,0x1f,
0x01,0x19,0x11,0xc1,
0x63,0x85,0x21,0x71
}; //0,1,2,3,4,5,6,7,8,9,A,b,c,d,e,F
```

#### LCD1602

##### LCD1602 接口图

![]( typorafile\LCD.png)

引脚说明LCD1602:
![]( typorafile\LCD1.png)



##### 控制器接口说明:

基本操作时序:
![]( typorafile\LCD2.png)

状态字说明:

![]( typorafile\LCD3.png)

**注意**: 对控制器每次进行读写操作之前, 都必须进行读写检测, 确保STA7为0.

RAM 地址映射图:
![]( typorafile\LCD4.png)

控制器内部带有80X8位(80字节)的RAM缓冲区.

##### 命令和驱动

**驱动说明：**

1. 当EN = 0时，数据位和RS位和P4～P7位可以改变 
2. 当EN= 1时，数据位内容被写入LCD 
3. 当RS = 0时，写入的为指令 
4. 当RS = 1时，写入的为数据（地址） 

**驱动流程：**

**1. 写入指令：**

1) EN = 0 （LCD使能禁止） 
2) 短延时 
3) RS = 0 （准备写入指令）
4) DATA = 指令的高4位（ATA代表D7、D6、D5、D4，下同） 
5) 短延时 
6) EN = 1 （LCD使能允许，指令写入） 
7) 短延时 
8) EN = 0 （LCD使能禁止） 
9) DATA = 指令的低4位 
10) 短延时 
11) EN = 1 （LCD使能允许，指令写入） 
12) 短延时 
13) EN = 0 （LCD使能禁止） 
14) 短延时 

**2. 写入数据：**

1) EN = 0 （LCD使能禁止） 
2) 短延时 
3) RS = 1 （准备写入数据）
4) DATA = 数据的高4位
5) 短延时 
6) EN = 1 （LCD使能允许，数据写入） 
7) 短延时 
8) EN = 0 （LCD使能禁止） 
9) DATA = 数据的低4位 
10) 短延时 
11) EN = 1 （LCD使能允许，数据写入） 
12) 短延时 
13) EN = 0 （LCD使能禁止） 
14) 短延时 

可以定义两个函数来实现以上指令:

```c
sbit rs=P1^0;//H数据，L命令
sbit lcden=P2^5;//高脉冲使能，使能脉宽最小150ns
sbit rw=P1^1;

void delay(unsigned char x)
{	unsigned int y;
	for(;x>0;x--) 
		for(y=100;y>0;y--){};
}

void lcdwrdata(unsigned char dat)
{	rs = 1;//写数据时RS拉高
	lcden = 1;
	P0 = dat;
	delay(6);
	lcden = 0;
	delay(6);
}
void lcdwrcom(unsigned char cdat)//写指令数据到LCD  
{
  rs = 0;//写指令时RS拉低
  lcden = 1;
  P0 = cdat;//
  delay(6);//不加此延时将导致不能写入指令，但能写入显示数据
  lcden = 0;
  delay(6);
}
```

**3. 初始化(复位过程):**

![]( typorafile\LCD5.png)

```c
void lcd_init()
{
	lcdwrcom(0x38);//0x38设置显示模式为：16X2 显示,5X7 点阵,8 位数据接口
	lcdwrcom(0x0e);//打开显示光标闪烁
	lcdwrcom(0x06);//当读或写一个字符后地址指针加1, 且光标加1.
	lcdwrcom(0x01);//数据指针清零
}
```

| 指令码     | 功能                                                         |
| ---------- | ------------------------------------------------------------ |
| 0011 1000  | 设置16*2显示,$5\times 7$点阵,8位数据接口                     |
| 0000 1DCB  | D=1 开显示;   D=0 关显示.<br />C=1 显示光标;    C=0不显示光标.<br />B=1 光标闪烁;   B=0 光标不显示. |
| 0000 01NS  | N=1 当读或写一个字符后地址指针加1, 且光标加1<br />N=0 当读或写一个字符后地址指针减1, 且光标减1<br />S=1 当写一个字符, 整屏显示左移(N=1)或右移(N=0),<br />(光标不动而屏幕移动)<br />S=0 当写一个字符, 整屏显示不移动 |
| 80H+地址码 | (0-0x27, 40-67h), 设置数据指针地址.                          |
| 0x01       | 显示清屏: 数据指针和所有显示清零.                            |
| 0x02       | 显示回车: 数据指针清零.                                      |

![]( typorafile\LCD6.png)

##### 自定义字符

LCD1602 能存储8个自定义字符, 首地址分别为: 0X40,0X48,0X50,0X58,0X60,0X68,0X70,0X78

由于每个字符都是 $5\times 7$ 的点阵, 比如0x40~0x47 这八个字节构成 $8\times 8$ 的点阵, 但是只有每行的低五位和前七列. 如图所示:

<img src="typorafile\LCD7.png" style="zoom: 67%;" />

每个地址对应一行(按字节寻址). 存储是两步实现的

1. 向LCD1602 发送指令, 定位行;
2. 写入每行对应的数据;

比如将汉字"十"存储到首地址为 0x40:

```c
uchar t_code1[]={0x15,0x1F,0x04,0x04,0x1C,0x11,0x1F,0x00};//自定义的一个5*7点阵 截图里的编码
uchar t_code2[]={0x15,0x1F,0x04,0x00,0x04,0x1F,0x15,0x00};

// Write a command
void write_command(uchar com)
{ lcden = 0;
  rs = 0;
  rw = 0;
  P0 = com;
  en = 1;
  _nop_();
  en = 0;
  delay(6);
}

// Write Data
void write_data(uchar _data)
{ lcden = 0;
  rs = 1;
  rw = 0;
  P0 = _data;
  en = 1;
  _nop_();
  en = 0;
  delay(6);   
}

write_command(0x40); // line1
write_data(0x04);
write_command(0x41); // line2
write_data(0x04);
write_command(0x42); // line3
write_data(0x3F);
write_command(0x43); // line4
write_data(0x04);
write_command(0x44); // line5
write_data(0x04);
write_command(0x45); // line6
write_data(0x04);
write_command(0x46); // line7
write_data(0x04);

```

显示自定义字符也是两个步骤:

1. 向LCD1602 发送指令, 定位数据指针;
2. 写入每行对应的数据;

## 附录 电阻的识别

## 附录 焊接技术

## 附录 WiFi控制

## 附录 None